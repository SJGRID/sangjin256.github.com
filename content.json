{"meta":{"title":"SJ의 프로그래밍","subtitle":"게임개발과 알고리즘 공부","description":"게임 개발을 공부하고 있는 대학생입니다.","author":"Sangjin Lee","url":"http://sangjin256.github.io","root":"/"},"pages":[],"posts":[{"title":"정렬 알고리즘","slug":"sort","date":"2020-05-30T02:39:22.000Z","updated":"2020-05-30T14:13:31.969Z","comments":true,"path":"2020/05/30/sort/[object Object]/[object Object]/","link":"","permalink":"http://sangjin256.github.io/2020/05/30/sort/[object%20Object]/[object%20Object]/","excerpt":"","text":"정렬이란?정렬(sorting)은 이름, 학번, 키 등 핵심 항목의 대소 관계에 따라 데이터 집합을 일정한 순서로 줄지어 늘어서도록 바꾸는 작업을 말한다. 정렬을 하면 검색을 더 쉽게 할 수 있게 된다. swap 메소드기본적으로 아래의 정렬들에서 쓸 swap 메소드를 미리 정의하는게 편합니다. 12345static void Swap(int[] arr, int a, int b)&#123; int tmp = arr[a]; arr[a] = arr[b]; arr[b] = tmp;&#125; 버블 정렬O(n2)시간에 동작이웃한 두 요소의 대소 관계를 비교하여 교환을 반복하는 정렬 방법 기본 코드a[j-1]과 a[j]를 비교해서 앞쪽이 크면 교환하고 그 이후의 비교, 교환 과정은 바로 앞쪽에서 수행해야 하므로 j의 값이 1씩 감소한다.각 과정에서 앞쪽 i개의 요소는 정렬이 끝난 상태라고 가정하므로 한 번의 과정에서는 j의 값이 i+1이 될 때까지 비교, 교환을 수행하면 된다. 1234567static void BubbleSort(int[] a, int n)&#123; for(int i = 0; i &lt; n-1; i++)&#123; for(int j = n-1; j &gt; i; j--)&#123; if(a[j-1] &gt; a[j]) Swap(a, j-1, j); &#125; &#125;&#125; 알고리즘 개선각각의 과정에서 비교, 교환을 하다가 어떤 시점 이후에 교환이 수행되지 않는다면 그보다 앞쪽의 요소는 이미 정렬을 마친 상태라고 생각해도 무방따라서 마지막으로 요소를 교환한 위치를 저장한 다음에, 다음 과정에서 그 위치까지만 비교, 교환을 수행하면 된다. 12345678910111213static void BubbleSort(int[] a, int n)&#123; int k = 0; while(k &lt; n-1)&#123; int last = n-1; for(int j = n-1; j &gt; k; j--)&#123; if(a[j-1] &gt; a[j])&#123; Swap(a, j-1, j); last = j; &#125; &#125; k = last; &#125;&#125; 병합 정렬O(nlogn)시간에 동작배열을 앞부분과 뒷부분으로 나누어 각각 정렬한 다음 병합하는 작업을 반복하는 정렬 방법배열의 앞부분을 병합 정렬로 정렬하고 배열의 뒷부분을 병합 정렬로 정렬해서마지막으로 배열의 앞부분과 뒷부분을 병합하는 방법.따라서 재귀를 사용한다. 1234567891011121314151617181920212223242526class MergeSort&#123; static int[] buff; static void __MergeSort(int[] a, int left, int right)&#123; if(left &lt; right)&#123; int i; int center = (left + right) / 2; int p = 0; int j = 0; int k = left; __MergeSort(a, left, center); __MergeSort(a, center+1, right); for(i = left; i &lt;= center; i++) buff[p++] = a[i]; while(i &lt;= right &amp;&amp; j &lt; p) a[k++] = (buff[j] &lt;= a[i]) ? buff[j++] : a[i++]; while(j &lt; p) a[k++] = buff[j++]; &#125; &#125; static void MergeSort(int[] a, int n)&#123; buff = new int[n]; __MergeSort(a, 0, n-1); buff = null; &#125;&#125; 퀵 정렬O(nlogn)시간에 동작일반적으로 사용되고 있는 아주 빠른 정렬 알고리즘2개의 그룹을 나누는 기준인 피벗을 정하고(보통 중앙) 피벗 이하의 요소를 배열 왼쪽으로, 이상의 요소를 배열 오른쪽으로 옮겨야 함.그렇게 하기 위해서 아래의 작업을 먼저 수행피벗을 x, 왼쪽 끝 요소의 인덱스 pl을 왼쪽 커서, 오른쪽 끝 요소의 인덱스 pr을 오른쪽 커서라고 할때 a[pl] &gt;= x가 성립하는 요소를 찾을 때까지 pl을 오른쪽으로 스캔 a[pr] &lt;= x가 성립하는 요소를 찾을 때까지 pr을 왼쪽으로 스캔 스캔이 완료되면 a[pl]과 a[pr]의 값을 교환하고 다시 스캔을 진행한다.스캔을 진행하다보면 pl과 pr이 교차하는 지점이 나오는데 그 지점으로 나뉘는 두 개의 그룹을 가지고 다시 퀵 정렬을 시작한다. 1234567891011121314static void QuickSort(int[] a, int left, int right)&#123; int pl = left; int pr = right; int x = a[(pl+pr) / 2]; do&#123; while(a[pl] &lt; x) pl++; while(a[pr] &gt; x) pr--; if(pl &lt;= pr) Swap(a, pl++, pr--); &#125; while(pl &lt;= pr); if(left &lt; pr) QuickSort(a, left, pr); if(pl &lt; right) QuickSort(a, pl, right);&#125; 비재귀적인 퀵 정렬재귀는 함수를 호출하기 때문에 직관적이기는 하지만 비재귀에 비해 시간 성능이 저하된다.재귀가 더 좋을때도 있지만 대부분의 경우에는 비재귀가 더 효율적인데 퀵 정렬같은 정렬 알고리즘이 그 예이다. 12345678910111213141516171819202122232425262728static void QuickSort(int[] a, int left, int right)&#123; Stack&lt;int&gt; lstack = new Stack&lt;int&gt;(right - left + 1); Stack&lt;int&gt; rstack = new Stack&lt;int&gt;(right - left + 1); lstack.Push(left); rstack.Pop(right); while(lstack.count != 0)&#123; int pl = left = lstack.Pop(); int pr = right = rstack.Pop(); int x = a[(left + right) / 2]; do&#123; while(a[pl] &lt; x) pl++; while(a[pr] &gt; x) pr--; if(pl &lt;= pr) Swap(a, pl++, pr--); &#125; while(pl &lt;= pr); if(left &lt; pr)&#123; lstack.Push(left); rstack.Push(pr); &#125; if(pl &lt; right)&#123; lstack.Push(pl); rstack.Push(right); &#125; &#125;&#125; 힙 정렬O(nlogn)시간에 동작힙(heap)을 사용하는 정렬 방법힙은 &#39;부모의 값이 자식의 값보다 항상 크다’(또는 그 반대)는 조건을 만족하는 완전이진트리가장 큰 값이 루트에 위치한다는 특징을 이용downheap 메소드를 사용하여 a[left] ~ a[right]의 요소를 힙으로 만들고 루트(a[0])에 있는 가장 큰 값을 빼내어 배열 마지막 요소와 바꾸고 배열의 나머지 부분을 다시 힙으로 만드는 과정을 반복하여 정렬을 수행 1234567891011121314151617181920212223static void DownHeap(int[] a, int left, int right)&#123; int tmp = a[left]; int child; int parent; for(parent = left; parent &lt; (right + 1) / 2; parent = child)&#123; int cl = parent * 2 + 1; int cr = cl + 1; child = (cr &lt;= right &amp;&amp; a[cr] &gt; a[cl]) ? cr : cl; if(tmp &gt;= a[child]) break; a[parent] = a[child]; &#125; a[parent] = tmp;&#125;static void HeapSort(int[] a, int n)&#123; for(int i = (n-1) / 2; i &gt;= 0; i--) DownHeap(a, i, n-1); for(int i = n-1; i &gt; 0; i--)&#123; Swap(a, 0, i); DownHeap(a, 0, i-1); &#125;&#125; 계수 정렬O(n)시간에 동작, 최악의 경우에는 O(n2)시간에 동작배열에서 각 숫자가 몇번 들어가는지를 이용하는 정렬 방법먼저 각 숫자가 몇 번 들어가는지를 세어 주고이 횟수를 누적 합 배열로 만들어준다.그리고 나서 처음 수열을 역순으로 살펴보면서 누적 합 배열과 비교하며 자리를 찾아간다.원소의 값이 크면 클수록 퀵정렬이나 힙정렬이 더 빠르다. 따라서 원소의 값이 아주 작을 때만 사용하는 것이 좋다.(0~10) 123456789101112131415161718static int[] CountingSort(int[] a, int n)&#123; int[] tmp = new int[a의 최댓값 + 1]; int[] result = new int[n]; for(int i = 0; i &lt; n; i++)&#123; tmp[a[i]]++; &#125; for(int i = 1; i &lt; tmp.Length; i++)&#123; tmp[i] += tmp[i-1]; &#125; for(int i = n-1; i &gt;= 0; i--)&#123; result[--tmp[a[i]]] = a[i]; &#125; return result;&#125;","categories":[{"name":"알고리즘","slug":"알고리즘","permalink":"http://sangjin256.github.io/categories/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/"},{"name":"정렬","slug":"알고리즘/정렬","permalink":"http://sangjin256.github.io/categories/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/%EC%A0%95%EB%A0%AC/"}],"tags":[{"name":"정렬","slug":"정렬","permalink":"http://sangjin256.github.io/tags/%EC%A0%95%EB%A0%AC/"},{"name":"소트","slug":"소트","permalink":"http://sangjin256.github.io/tags/%EC%86%8C%ED%8A%B8/"},{"name":"버블정렬","slug":"버블정렬","permalink":"http://sangjin256.github.io/tags/%EB%B2%84%EB%B8%94%EC%A0%95%EB%A0%AC/"},{"name":"병합정렬","slug":"병합정렬","permalink":"http://sangjin256.github.io/tags/%EB%B3%91%ED%95%A9%EC%A0%95%EB%A0%AC/"},{"name":"퀵정렬","slug":"퀵정렬","permalink":"http://sangjin256.github.io/tags/%ED%80%B5%EC%A0%95%EB%A0%AC/"},{"name":"힙 정렬","slug":"힙-정렬","permalink":"http://sangjin256.github.io/tags/%ED%9E%99-%EC%A0%95%EB%A0%AC/"},{"name":"계수정렬","slug":"계수정렬","permalink":"http://sangjin256.github.io/tags/%EA%B3%84%EC%88%98%EC%A0%95%EB%A0%AC/"},{"name":"도수정렬","slug":"도수정렬","permalink":"http://sangjin256.github.io/tags/%EB%8F%84%EC%88%98%EC%A0%95%EB%A0%AC/"}]},{"title":"너의 결혼식 감상평","slug":"onyourweddingday","date":"2020-05-30T01:37:14.000Z","updated":"2020-05-30T02:28:20.073Z","comments":true,"path":"2020/05/30/onyourweddingday/[object Object]/[object Object]/","link":"","permalink":"http://sangjin256.github.io/2020/05/30/onyourweddingday/[object%20Object]/[object%20Object]/","excerpt":"","text":"“첫사랑은 이루어지지 않는다”라는 말이 있다. 나는 경험상 이 말을 믿게 되었다. 그러나 내 주변에는 첫사랑으로 2000일이 넘도록 사귀고 있는 현재진행형 커플도 있다. 하지만 이런 경우가 많은가? 절대 그렇지 않다. 주변을 둘러보면 알 수 있을 것이다. 그럼 왜 첫사랑은 이루어지지 않는 것일까?이 영화는 ‘첫사랑’에 대한 소재를 아주 현실적으로 사용하고 있다. 주인공 ‘황우연’은 고등학교 때 전학 온 여주 ‘환승희’에게 한눈에 반한 뒤로 세월이 흘러도 쭉 첫사랑인 그녀만 바라보는 캐릭터이다. 그러나 매번 만날때마다 타이밍이 좋지 않다. 한번은 여주에게 남친이 있고 한번은 남주에게 여친이 있고…(감독이 정말 잔인하다.) 이 영화는 ‘황우연’의 시점으로만 이야기가 전개되는데 이 시점이 ‘황우연’에게 더 공감되고 응원하게 만드는 데에 큰 역할을 했다고 생각한다. 양쪽 시점으로 전개됐다면 서로의 상황을 이해시키려는 감독의 목적에 의해 한명에게 이입시킬때보다 ‘영화’라는 매체가 부각되어 큰 여운을 주지는 못했을 것이다.‘황우연’의 시점으로 그가 여주를 얼마나 사랑했는지를 알기에 엔딩이 더욱 안쓰러웠고 씁쓸했다. 하지만 인생이라는 게 다 그렇지 않겠는가? 첫사랑은 ‘첫’사랑일 뿐이다. 영화에 나온 대사처럼 버스가 가면 다음 버스가 오듯이 첫사랑의 어리숙함을 딛고 일어서야만 더욱 더 성장함으로서 진실된 사랑을 할 수 있다. 이 영화의 포스터는 사진을 세로로 이어붙인 형태인데 영화를 다 보고 나니 이것이 필름을 상징한다는 느낌을 받았다. 필름을 재생하면 사진 하나하나가 지나가면서 한편의 영화가 되듯이, 첫사랑도 흘러흘러 하나의 추억으로 남는다는 감독의 의도가 담긴 게 아닐까?자, 그럼 처음 던졌던 질문에 대한 답은 나왔다고 생각한다. 이 글을 읽은 독자들도 한번 자신의 인생을 되돌아보며 첫사랑에 대해 생각해보자. 자신의 첫사랑이 어땠는지를.","categories":[{"name":"리뷰","slug":"리뷰","permalink":"http://sangjin256.github.io/categories/%EB%A6%AC%EB%B7%B0/"},{"name":"영화","slug":"리뷰/영화","permalink":"http://sangjin256.github.io/categories/%EB%A6%AC%EB%B7%B0/%EC%98%81%ED%99%94/"}],"tags":[{"name":"영화 - 리뷰 - 감상 - 너의결혼식","slug":"영화-리뷰-감상-너의결혼식","permalink":"http://sangjin256.github.io/tags/%EC%98%81%ED%99%94-%EB%A6%AC%EB%B7%B0-%EA%B0%90%EC%83%81-%EB%84%88%EC%9D%98%EA%B2%B0%ED%98%BC%EC%8B%9D/"}]},{"title":"포스팅을 위한 hexo 문법들","slug":"starting","date":"2020-05-28T12:05:57.000Z","updated":"2020-05-29T15:07:15.364Z","comments":true,"path":"2020/05/28/starting/[object Object]/[object Object]/","link":"","permalink":"http://sangjin256.github.io/2020/05/28/starting/[object%20Object]/[object%20Object]/","excerpt":"","text":"마크다운 문법1. 제목 크기 변경123456# 제목 1## 제목 2### 제목 3#### 제목 4##### 제목 5###### 제목 6 아래와 같이 표시된다. 제목 1제목 2제목 3제목 4제목 5제목 62. 인용문123&gt; “좋은 디자인은 그 때문에 소모되는 비용보다 빠르게 가치가 쌓인다.”&gt;&gt; “좋은 디자인은 그 때문에 소모되는 비용보다 빠르게 가치가 쌓인다.”&gt;&gt;&gt; “좋은 디자인은 그 때문에 소모되는 비용보다 빠르게 가치가 쌓인다.” 아래와 같이 표시된다. “좋은 디자인은 그 때문에 소모되는 비용보다 빠르게 가치가 쌓인다.” “좋은 디자인은 그 때문에 소모되는 비용보다 빠르게 가치가 쌓인다.” “좋은 디자인은 그 때문에 소모되는 비용보다 빠르게 가치가 쌓인다.” 저자와 출처 제목이 있는 경우 아래와 같이 사용한다.123&#123;% blockquote 토마스 C. 게일,Thomas C. Gale %&#125;좋은 디자인은 그 때문에 소모되는 비용보다 빠르게 가치가 쌓인다.&#123;% endblockquote %&#125; 좋은 디자인은 그 때문에 소모되는 비용보다 빠르게 가치가 쌓인다. 토마스 C. 게일Thomas C. Gale 3. 글머리 기호1234567891011* 프로그래밍 * 프로그래밍 * 프로그래밍 + 프로그래밍 + 프로그래밍 + 프로그래밍- 프로그래밍 - 프로그래밍 - 프로그래밍 아래와 같이 표시된다.첫번째 줄보다 2칸 이상씩 띄어서 써야한다. 프로그래밍 프로그래밍 프로그래밍 프로그래밍 프로그래밍 프로그래밍 프로그래밍 프로그래밍 프로그래밍 4. 강조123이텔릭체 - *이텔릭체* or _이텔릭체_두껍게 - **두껍게** or __두껍게__두껍게+이텔릭체 - **_이텔릭체_** 아래와 같이 표시된다.이텔릭체 - 이텔릭체 or 이텔릭체두껍게 - 두껍게 or 두껍게두껍게+이텔릭체 - 이텔릭체 5. 코드 넣기1234567using System;class Lecture&#123; public static void Main(stirng[] args)&#123; Console.WriteLine(\"안녕하세요\"); &#125;&#125; 코드 시작과 끝에 Tab위에있는 버튼을 3번씩 쓰면된다. 6. 수평선12***- - - 모두 아래와 같이 표시된다. 7. 링크12[Google](https:&#x2F;&#x2F;google.com)[Naver](https:&#x2F;&#x2F;naver.com) GoogleNaver 8. 유튜브1&#123;% youtube video_id %&#125; video_id부분에 ‘비디오 공유’를 눌러서 나오는 url의 뒷부분에 적힌 아이디를 넣으면 된다. 1&#123;% youtube eDEFolvLn0A %&#125; 9. 포스트 삽입12&#123;% post_path slug %&#125;&#123;% post_link slug [title] %&#125; 아래와 깉이 slug[title]부분에 포스트 파일 제목을 입력하면 된다. 1&#123;% post_link first %&#125; 안녕하세요! 10. 이미지 삽입123456먼저 source폴더 안에 image폴더를 만들어준 후 그안에 사진을 넣고![](&#x2F;image&#x2F;IMG_0191.jpeg)와 같이 적는다.이미지 크기를 조정하고 싶을 경우에는 아래와 같이 적어야 한다.&lt;img src&#x3D;&quot;&#x2F;image&#x2F;IMG_0191.jpeg&quot; width&#x3D;&quot;400px&quot; height&#x3D;&quot;300px&quot; title&#x3D;&quot;크기 조정&quot;&gt;&lt;&#x2F;img&gt;&lt;br&#x2F;&gt; 이미지에 하이퍼링크 달기1[![](&#x2F;image&#x2F;IMG_0191.jpeg)](https:&#x2F;&#x2F;sangjin256.github.io) 포스팅 작성 완료 후 업로드방법 1hexo generatehexo deploy 방법2hexo clean &amp;&amp; hexo deploy -g","categories":[{"name":"잡담","slug":"잡담","permalink":"http://sangjin256.github.io/categories/%EC%9E%A1%EB%8B%B4/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://sangjin256.github.io/tags/hexo/"},{"name":"마크다운","slug":"마크다운","permalink":"http://sangjin256.github.io/tags/%EB%A7%88%ED%81%AC%EB%8B%A4%EC%9A%B4/"}]},{"title":"안녕하세요!","slug":"first","date":"2020-05-28T08:57:18.000Z","updated":"2020-05-28T12:07:26.192Z","comments":true,"path":"2020/05/28/first/[object Object]/[object Object]/","link":"","permalink":"http://sangjin256.github.io/2020/05/28/first/[object%20Object]/[object%20Object]/","excerpt":"","text":"안녕하세요 현재 대학생인 게임개발자 지망생입니다.앞으로 여기에다가 게임 개발 일지나 알고리즘 풀이등을 올릴 예정입니다.자기계발을 위해 조금씩이라도 꾸준히 포스팅하겠습니다!","categories":[{"name":"잡담","slug":"잡담","permalink":"http://sangjin256.github.io/categories/%EC%9E%A1%EB%8B%B4/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://sangjin256.github.io/tags/hexo/"},{"name":"알고리즘","slug":"알고리즘","permalink":"http://sangjin256.github.io/tags/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/"},{"name":"게임 개발","slug":"게임-개발","permalink":"http://sangjin256.github.io/tags/%EA%B2%8C%EC%9E%84-%EA%B0%9C%EB%B0%9C/"},{"name":"시작","slug":"시작","permalink":"http://sangjin256.github.io/tags/%EC%8B%9C%EC%9E%91/"}]}],"categories":[{"name":"알고리즘","slug":"알고리즘","permalink":"http://sangjin256.github.io/categories/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/"},{"name":"정렬","slug":"알고리즘/정렬","permalink":"http://sangjin256.github.io/categories/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/%EC%A0%95%EB%A0%AC/"},{"name":"리뷰","slug":"리뷰","permalink":"http://sangjin256.github.io/categories/%EB%A6%AC%EB%B7%B0/"},{"name":"영화","slug":"리뷰/영화","permalink":"http://sangjin256.github.io/categories/%EB%A6%AC%EB%B7%B0/%EC%98%81%ED%99%94/"},{"name":"잡담","slug":"잡담","permalink":"http://sangjin256.github.io/categories/%EC%9E%A1%EB%8B%B4/"}],"tags":[{"name":"정렬","slug":"정렬","permalink":"http://sangjin256.github.io/tags/%EC%A0%95%EB%A0%AC/"},{"name":"소트","slug":"소트","permalink":"http://sangjin256.github.io/tags/%EC%86%8C%ED%8A%B8/"},{"name":"버블정렬","slug":"버블정렬","permalink":"http://sangjin256.github.io/tags/%EB%B2%84%EB%B8%94%EC%A0%95%EB%A0%AC/"},{"name":"병합정렬","slug":"병합정렬","permalink":"http://sangjin256.github.io/tags/%EB%B3%91%ED%95%A9%EC%A0%95%EB%A0%AC/"},{"name":"퀵정렬","slug":"퀵정렬","permalink":"http://sangjin256.github.io/tags/%ED%80%B5%EC%A0%95%EB%A0%AC/"},{"name":"힙 정렬","slug":"힙-정렬","permalink":"http://sangjin256.github.io/tags/%ED%9E%99-%EC%A0%95%EB%A0%AC/"},{"name":"계수정렬","slug":"계수정렬","permalink":"http://sangjin256.github.io/tags/%EA%B3%84%EC%88%98%EC%A0%95%EB%A0%AC/"},{"name":"도수정렬","slug":"도수정렬","permalink":"http://sangjin256.github.io/tags/%EB%8F%84%EC%88%98%EC%A0%95%EB%A0%AC/"},{"name":"영화 - 리뷰 - 감상 - 너의결혼식","slug":"영화-리뷰-감상-너의결혼식","permalink":"http://sangjin256.github.io/tags/%EC%98%81%ED%99%94-%EB%A6%AC%EB%B7%B0-%EA%B0%90%EC%83%81-%EB%84%88%EC%9D%98%EA%B2%B0%ED%98%BC%EC%8B%9D/"},{"name":"hexo","slug":"hexo","permalink":"http://sangjin256.github.io/tags/hexo/"},{"name":"마크다운","slug":"마크다운","permalink":"http://sangjin256.github.io/tags/%EB%A7%88%ED%81%AC%EB%8B%A4%EC%9A%B4/"},{"name":"알고리즘","slug":"알고리즘","permalink":"http://sangjin256.github.io/tags/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/"},{"name":"게임 개발","slug":"게임-개발","permalink":"http://sangjin256.github.io/tags/%EA%B2%8C%EC%9E%84-%EA%B0%9C%EB%B0%9C/"},{"name":"시작","slug":"시작","permalink":"http://sangjin256.github.io/tags/%EC%8B%9C%EC%9E%91/"}]}